Index: .idea/runConfigurations.xml
===================================================================
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
deleted file mode 100644
--- a/.idea/runConfigurations.xml	(revision 55d5c4abb17c54bfdf61b5492a260915fa0ae60e)
+++ /dev/null	(revision 55d5c4abb17c54bfdf61b5492a260915fa0ae60e)
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="RunConfigurationProducerService">
-    <option name="ignoredProducers">
-      <set>
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.AllInPackageGradleConfigurationProducer" />
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestClassGradleConfigurationProducer" />
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestMethodGradleConfigurationProducer" />
-      </set>
-    </option>
-  </component>
-</project>
\ No newline at end of file
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <option name=\"testRunner\" value=\"PLATFORM\" />\r\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"gradleJvm\" value=\"1.8\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n            <option value=\"$PROJECT_DIR$/aimo\" />\r\n            <option value=\"$PROJECT_DIR$/app\" />\r\n          </set>\r\n        </option>\r\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/gradle.xml b/.idea/gradle.xml
--- a/.idea/gradle.xml	(revision 55d5c4abb17c54bfdf61b5492a260915fa0ae60e)
+++ b/.idea/gradle.xml	(date 1669101390395)
@@ -4,7 +4,7 @@
   <component name="GradleSettings">
     <option name="linkedExternalProjectsSettings">
       <GradleProjectSettings>
-        <option name="testRunner" value="PLATFORM" />
+        <option name="testRunner" value="GRADLE" />
         <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
         <option name="gradleJvm" value="1.8" />
@@ -15,7 +15,6 @@
             <option value="$PROJECT_DIR$/app" />
           </set>
         </option>
-        <option name="resolveModulePerSourceSet" value="false" />
       </GradleProjectSettings>
     </option>
   </component>
Index: aimo/src/main/java/com/library/aimo/video/record/VideoBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.library.aimo.video.record;\r\n\r\n\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.media.MediaCodec;\r\nimport android.media.MediaCodecInfo;\r\nimport android.media.MediaFormat;\r\nimport android.media.MediaMuxer;\r\nimport android.os.Build;\r\n\r\nimport com.library.aimo.EasyLibUtils;\r\nimport com.library.aimo.util.ImoLog;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.concurrent.CopyOnWriteArrayList;\r\n\r\n/**\r\n * 图片合成视频\r\n */\r\npublic class VideoBuilder extends Thread {\r\n\r\n    private final int mFrameRate;\r\n    private final File out;\r\n    private final int bitRate;\r\n\r\n    private MediaCodec mediaCodec;\r\n    public boolean isRunning;\r\n    private MediaMuxer mediaMuxer;\r\n    private int mTrackIndex;\r\n    private boolean mMuxerStarted;\r\n    private int colorFormat;\r\n\r\n    public static File[] sort(File[] s) {\r\n        //中间值\r\n        File temp = null;\r\n        //外循环:我认为最小的数,从0~长度-1\r\n        for (int j = 0; j < s.length - 1; j++) {\r\n            //最小值:假设第一个数就是最小的\r\n            String min = s[j].getName();\r\n            //记录最小数的下标的\r\n            int minIndex = j;\r\n            //内循环:拿我认为的最小的数和后面的数一个个进行比较\r\n            for (int k = j + 1; k < s.length; k++) {\r\n                //找到最小值\r\n                if (Long.parseLong(min.substring(0, min.indexOf(\".\"))) > Long.parseLong(s[k].getName().substring(0, s[k].getName().indexOf(\".\")))) {\r\n                    //修改最小\r\n                    min = s[k].getName();\r\n                    minIndex = k;\r\n                }\r\n            }\r\n            //当退出内层循环就找到这次的最小值\r\n            //交换位置\r\n            temp = s[j];\r\n            s[j] = s[minIndex];\r\n            s[minIndex] = temp;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    public static void clearCaches(File cacheDir) {\r\n        if (cacheDir != null) {\r\n            File[] files = cacheDir.listFiles();\r\n            if (files != null) {\r\n                for (File itemFile : files) {\r\n                    itemFile.delete();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private File cacheDirs;\r\n\r\n    public static File getOutputVideo() {\r\n        return new File(EasyLibUtils.getApp().getCacheDir(), \"video_encoded.mp4\");\r\n        // return new File(Environment.getExternalStorageDirectory(), \"auf/video_encoded.mp4\");\r\n    }\r\n\r\n    public VideoBuilder(File file, int time) {\r\n        this.cacheDirs = file;\r\n        File[] files = file.listFiles();\r\n        files = sort(files);\r\n        inputs = new CopyOnWriteArrayList<>();\r\n        for (File itemFile : files) {\r\n            inputs.add(itemFile.toString());\r\n        }\r\n        totalSize = inputs.size();\r\n\r\n        mFrameRate = totalSize / time;\r\n\r\n        out = getOutputVideo();\r\n\r\n        out.deleteOnExit();\r\n\r\n        out.getParentFile().mkdirs();\r\n        try {\r\n            out.createNewFile();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        this.bitRate = 0;\r\n\r\n        this.isRunning = false;\r\n        this.mTrackIndex = 0;\r\n        this.mMuxerStarted = false;\r\n\r\n        init(480, 640);\r\n\r\n        mediaCodec.start();\r\n    }\r\n\r\n\r\n    private void init(int width, int height) {\r\n\r\n        int bitRate0 = bitRate;\r\n        if (bitRate == 0) {\r\n            bitRate0 = width * height * 16;//Bitmap.Config.RGB_565\r\n        }\r\n\r\n        int[] formats = RGB2YuvTool.getMediaCodecList();\r\n\r\n        lab:\r\n        for (int format : formats) {\r\n            switch (format) {\r\n                case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar: // yuv420sp\r\n                case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar: // yuv420p\r\n                case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedSemiPlanar: // yuv420psp\r\n                case MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420PackedPlanar: // yuv420pp\r\n                    colorFormat = format;\r\n                    break lab;\r\n            }\r\n        }\r\n\r\n        if (colorFormat <= 0) {\r\n            colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar;\r\n        }\r\n\r\n\r\n        MediaFormat mediaFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, width, height);//COLOR_FormatYUV420SemiPlanar\r\n        mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);\r\n        mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitRate0);\r\n        mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);\r\n        mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1);\r\n\r\n//\r\n//        对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。\r\n//        对于packed的YUV格式，每个像素点的Y,U,V是连续交*存储的。\r\n//\r\n        try {\r\n            mediaCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);\r\n            //创建生成MP4初始化对象\r\n            mediaMuxer = new MediaMuxer(out.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        mediaCodec.configure(mediaFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);\r\n\r\n        isRunning = true;\r\n    }\r\n\r\n\r\n    public void finish() {\r\n        isRunning = false;\r\n        if (mediaCodec != null) {\r\n            mediaCodec.stop();\r\n            mediaCodec.release();\r\n        }\r\n        if (mediaMuxer != null) {\r\n            try {\r\n                if (mMuxerStarted) {\r\n                    mediaMuxer.stop();\r\n                    mediaMuxer.release();\r\n                }\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private CopyOnWriteArrayList<String> inputs;\r\n\r\n\r\n    int totalSize = 0;\r\n\r\n\r\n    private int getSize(int size) {\r\n        return size / 4 * 4;\r\n    }\r\n\r\n    /**\r\n     * Generates the presentation time for frame N, in microseconds.\r\n     */\r\n    private long computePresentationTime(long frameIndex) {\r\n        return 132 + frameIndex * 1000000 / mFrameRate;\r\n    }\r\n\r\n\r\n    private void drainEncoder(boolean endOfStream, MediaCodec.BufferInfo bufferInfo) {\r\n        final int TIMEOUT_USEC = 10000;\r\n\r\n        ByteBuffer[] buffers = null;\r\n        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP) {\r\n            buffers = mediaCodec.getOutputBuffers();\r\n        }\r\n\r\n        if (endOfStream) {\r\n            try {\r\n                mediaCodec.signalEndOfInputStream();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n\r\n        while (true) {\r\n            int encoderStatus = mediaCodec.dequeueOutputBuffer(bufferInfo, TIMEOUT_USEC);\r\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\r\n                if (!endOfStream) {\r\n                    break; // out of while\r\n                } else {\r\n                    ImoLog.i(\"no output available, spinning to await EOS\");\r\n                }\r\n            } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\r\n                if (mMuxerStarted) {\r\n                    throw new RuntimeException(\"format changed twice\");\r\n                }\r\n\r\n                MediaFormat mediaFormat = mediaCodec.getOutputFormat();\r\n                mTrackIndex = mediaMuxer.addTrack(mediaFormat);\r\n                mediaMuxer.start();\r\n                mMuxerStarted = true;\r\n            } else if (encoderStatus < 0) {\r\n                ImoLog.i(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\r\n            } else {\r\n                ByteBuffer outputBuffer = null;\r\n                if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP) {\r\n                    outputBuffer = buffers[encoderStatus];\r\n                } else {\r\n                    outputBuffer = mediaCodec.getOutputBuffer(encoderStatus);\r\n                }\r\n\r\n                if (outputBuffer == null) {\r\n                    throw new RuntimeException(\"encoderOutputBuffer \"\r\n                            + encoderStatus + \" was null\");\r\n                }\r\n\r\n                if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {\r\n                    ImoLog.i(\"ignoring BUFFER_FLAG_CODEC_CONFIG\");\r\n                    bufferInfo.size = 0;\r\n                }\r\n\r\n                if (bufferInfo.size != 0) {\r\n                    if (!mMuxerStarted) {\r\n                        throw new RuntimeException(\"muxer hasn't started\");\r\n                    }\r\n\r\n                    // adjust the ByteBuffer values to match BufferInfo\r\n                    outputBuffer.position(bufferInfo.offset);\r\n                    outputBuffer.limit(bufferInfo.offset + bufferInfo.size);\r\n\r\n                    try {\r\n                        mediaMuxer.writeSampleData(mTrackIndex, outputBuffer, bufferInfo);\r\n                    } catch (Exception e) {\r\n                        ImoLog.i(\"Too many frames\");\r\n                    }\r\n\r\n                }\r\n\r\n                mediaCodec.releaseOutputBuffer(encoderStatus, false);\r\n\r\n                if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\r\n                    if (!endOfStream) {\r\n                        ImoLog.i(\"reached end of stream unexpectedly\");\r\n                    } else {\r\n                        ImoLog.i(\"end of stream reached\");\r\n                    }\r\n                    break; // out of while\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        final int TIMEOUT_USEC = 10000;\r\n        isRunning = true;\r\n        long generateIndex = 0;\r\n        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();\r\n\r\n        ByteBuffer[] buffers = null;\r\n        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP) {\r\n            buffers = mediaCodec.getInputBuffers();\r\n        }\r\n\r\n        while (isRunning) {\r\n\r\n            int inputBufferIndex = mediaCodec.dequeueInputBuffer(TIMEOUT_USEC);\r\n            if (inputBufferIndex >= 0) {\r\n                long ptsUsec = computePresentationTime(generateIndex);\r\n                if (inputs.size() == 0) {\r\n                    mediaCodec.queueInputBuffer(inputBufferIndex, 0, 0, ptsUsec,\r\n                            MediaCodec.BUFFER_FLAG_END_OF_STREAM);\r\n                    isRunning = false;\r\n                    drainEncoder(true, info);\r\n\r\n                } else {\r\n                    String filePath = inputs.remove(0);\r\n                    Bitmap bitmap = BitmapFactory.decodeFile(filePath);\r\n                    ImoLog.e(\"当前进度：\" + generateIndex + \"/\" + totalSize);\r\n                    if (bitmap != null) {\r\n                        byte[] input = RGB2YuvTool.getNV12(getSize(bitmap.getWidth()), getSize(bitmap.getHeight()), bitmap, colorFormat);//AvcEncoder.this.getNV21(bitmap);\r\n\r\n                        //有效的空的缓存区\r\n                        ByteBuffer inputBuffer = null;\r\n                        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP) {\r\n                            inputBuffer = buffers[inputBufferIndex];\r\n                        } else {\r\n                            inputBuffer = mediaCodec.getInputBuffer(inputBufferIndex);//inputBuffers[inputBufferIndex];\r\n                        }\r\n                        inputBuffer.clear();\r\n                        inputBuffer.put(input);\r\n                        //将数据放到编码队列\r\n                        mediaCodec.queueInputBuffer(inputBufferIndex, 0, input.length, ptsUsec, 0);\r\n                        drainEncoder(false, info);\r\n                    }\r\n                }\r\n\r\n                generateIndex++;\r\n            } else {\r\n                ImoLog.i(\"input buffer not available\");\r\n                try {\r\n                    Thread.sleep(50);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        finish();\r\n        clearCaches(cacheDirs);\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/aimo/src/main/java/com/library/aimo/video/record/VideoBuilder.java b/aimo/src/main/java/com/library/aimo/video/record/VideoBuilder.java
--- a/aimo/src/main/java/com/library/aimo/video/record/VideoBuilder.java	(revision 55d5c4abb17c54bfdf61b5492a260915fa0ae60e)
+++ b/aimo/src/main/java/com/library/aimo/video/record/VideoBuilder.java	(date 1669101390407)
@@ -144,6 +144,7 @@
         mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitRate0);
         mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);
         mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1);
+        mediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, 0);
 
 //
 //        对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。
